#!/usr/bin/python2.7

#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
    from thrift.protocol import fastbinary
except:
    fastbinary = None



class W:
    """
    Attributes:
     - a
     - c
     - v
     - t
    """

    thrift_spec = (
        None, # 0
        (1, TType.STRING, 'a', None, None, ), # 1
        (2, TType.I64, 'c', None, None, ), # 2
        (3, TType.DOUBLE, 'v', None, None, ), # 3
        (4, TType.I64, 't', None, None, ), # 4
    )

    def __init__(self, a=None, c=None, v=None, t=None,):
        self.a = a
        self.c = c
        self.v = v
        self.t = t

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.a = iprot.readString();
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.c = iprot.readI64();
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble();
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.t = iprot.readI64();
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('W')
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.STRING, 1)
            oprot.writeString(self.a)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.I64, 2)
            oprot.writeI64(self.c)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.t is not None:
            oprot.writeFieldBegin('t', TType.I64, 4)
            oprot.writeI64(self.t)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.a)
        value = (value * 31) ^ hash(self.c)
        value = (value * 31) ^ hash(self.v)
        value = (value * 31) ^ hash(self.t)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
    from thrift.protocol import fastbinary
except:
    fastbinary = None


class Iface:
    def c(self, w):
        """
        Parameters:
         - w
        """
        pass

    def d(self, w):
        """
        Parameters:
         - w
        """
        pass

    def w(self, w):
        """
        Parameters:
         - w
        """
        pass

    def b(self, w):
        """
        Parameters:
         - w
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def c(self, w):
        """
        Parameters:
         - w
        """
        self.send_c(w)
        return self.recv_c()

    def send_c(self, w):
        self._oprot.writeMessageBegin('c', TMessageType.CALL, self._seqid)
        args = c_args()
        args.w = w
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_c(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = c_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "c failed: unknown result");

    def d(self, w):
        """
        Parameters:
         - w
        """
        self.send_d(w)
        return self.recv_d()

    def send_d(self, w):
        self._oprot.writeMessageBegin('d', TMessageType.CALL, self._seqid)
        args = d_args()
        args.w = w
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_d(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = d_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "d failed: unknown result");

    def w(self, w):
        """
        Parameters:
         - w
        """
        self.send_w(w)
        return self.recv_w()

    def send_w(self, w):
        self._oprot.writeMessageBegin('w', TMessageType.CALL, self._seqid)
        args = w_args()
        args.w = w
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_w(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = w_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "w failed: unknown result");

    def b(self, w):
        """
        Parameters:
         - w
        """
        self.send_b(w)
        return self.recv_b()

    def send_b(self, w):
        self._oprot.writeMessageBegin('b', TMessageType.CALL, self._seqid)
        args = b_args()
        args.w = w
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_b(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = b_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "b failed: unknown result");


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["c"] = Processor.process_c
        self._processMap["d"] = Processor.process_d
        self._processMap["w"] = Processor.process_w
        self._processMap["b"] = Processor.process_b

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_c(self, seqid, iprot, oprot):
        args = c_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = c_result()
        result.success = self._handler.c(args.w)
        oprot.writeMessageBegin("c", TMessageType.REPLY, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_d(self, seqid, iprot, oprot):
        args = d_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = d_result()
        result.success = self._handler.d(args.w)
        oprot.writeMessageBegin("d", TMessageType.REPLY, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_w(self, seqid, iprot, oprot):
        args = w_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = w_result()
        result.success = self._handler.w(args.w)
        oprot.writeMessageBegin("w", TMessageType.REPLY, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_b(self, seqid, iprot, oprot):
        args = b_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = b_result()
        result.success = self._handler.b(args.w)
        oprot.writeMessageBegin("b", TMessageType.REPLY, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class c_args:
    """
    Attributes:
     - w
    """

    thrift_spec = (
        None, # 0
        (1, TType.STRUCT, 'w', (W, W.thrift_spec), None, ), # 1
    )

    def __init__(self, w=None,):
        self.w = w

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.w = W()
                    self.w.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('c_args')
        if self.w is not None:
            oprot.writeFieldBegin('w', TType.STRUCT, 1)
            self.w.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.w)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class c_result:
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ), # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64();
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('c_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class d_args:
    """
    Attributes:
     - w
    """

    thrift_spec = (
        None, # 0
        (1, TType.STRUCT, 'w', (W, W.thrift_spec), None, ), # 1
    )

    def __init__(self, w=None,):
        self.w = w

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.w = W()
                    self.w.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('d_args')
        if self.w is not None:
            oprot.writeFieldBegin('w', TType.STRUCT, 1)
            self.w.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.w)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class d_result:
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ), # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool();
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('d_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class w_args:
    """
    Attributes:
     - w
    """

    thrift_spec = (
        None, # 0
        (1, TType.STRUCT, 'w', (W, W.thrift_spec), None, ), # 1
    )

    def __init__(self, w=None,):
        self.w = w

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.w = W()
                    self.w.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('w_args')
        if self.w is not None:
            oprot.writeFieldBegin('w', TType.STRUCT, 1)
            self.w.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.w)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class w_result:
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ), # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool();
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('w_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class b_args:
    """
    Attributes:
     - w
    """

    thrift_spec = (
        None, # 0
        (1, TType.STRUCT, 'w', (W, W.thrift_spec), None, ), # 1
    )

    def __init__(self, w=None,):
        self.w = w

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.w = W()
                    self.w.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('b_args')
        if self.w is not None:
            oprot.writeFieldBegin('w', TType.STRUCT, 1)
            self.w.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.w)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class b_result:
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.DOUBLE, 'success', None, None, ), # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
            fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble();
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
            oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('b_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return


    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.iteritems()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


import sys
import glob
import time
import traceback
import os.path

import argparse
import re

ACCOUNT_REGEXP = r"^[_\-.0-9a-z]{1,250}$"
AMOUNT_REGEXP = r"^(0|[1-9][0-9]*).[0-9]{2}$"
FILENAME_REGEXP = r"^[_\-.0-9a-z]{1,255}$"
IP_REGEXP = r"^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$"
NUMERIC_REGEXP = r"^(0|[1-9][0-9]*)$"

class UniqueStore(argparse.Action):
    def __call__(self, parser, namespace, values, option_string):
        if getattr(namespace, self.dest, self.default) is not None:
            # print >> sys.stderr, "%s appears several times. " % option_string
            sys.exit(255)
        # print >> sys.stderr, "%s %s" % (option_string, values)
        setattr(namespace, self.dest, values)

class UniqueFlagStore(argparse._StoreTrueAction):
    def __call__(self, parser, namespace, values, option_string):
        if getattr(namespace, self.dest, self.default) is not False:
            # print >> sys.stderr, "%s appears several times. " % option_string
            sys.exit(255)
        setattr(namespace, self.dest, True)

class ArgumentParser(argparse.ArgumentParser):
    def _get_action_from_name(self, name):
        """Given a name, get the Action instance registered with this parser.
        If only it were made available in the ArgumentError object. It is
        passed as it's first arg...
        """
        container = self._actions
        if name is None:
            return None
        for action in container:
            if '/'.join(action.option_strings) == name:
                return action
            elif action.metavar == name:
                return action
            elif action.dest == name:
                return action

    def error(self, message):
        exc = sys.exc_info()[1]
        if exc:
            exc.argument = self._get_action_from_name(exc.argument_name)
            raise exc
        super(ArgumentParser, self).error(message)


from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol


try:
    parser = ArgumentParser()
    parser.add_argument('-a', required=True, action=UniqueStore)
    parser.add_argument('-s', action=UniqueStore)
    parser.add_argument('-i', action=UniqueStore)
    parser.add_argument('-p', action=UniqueStore,)
    parser.add_argument('-c', action=UniqueStore)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-n', action=UniqueStore)
    group.add_argument('-d', action=UniqueStore)
    group.add_argument('-w', action=UniqueStore)
    group.add_argument('-g', action=UniqueFlagStore)
    parser.add_argument('additional', nargs=argparse.REMAINDER)
    argsNamespace = parser.parse_args()
    # print >> sys.stderr, argsNamespace
    if len(argsNamespace.additional) > 0:
        # print >> sys.stderr, "Got %s not valid arguments" % len(args.additional)
        sys.exit(255)
    args = vars(argsNamespace)

    account_matcher = re.compile(ACCOUNT_REGEXP)
    if account_matcher.match(args['a']) is None:
        # print >> sys.stderr, "invalid account %s" % args['a']
        sys.exit(255)

    if args['s'] is None:
        args['s'] = 'bank.auth'
    else:
        authfile_matcher = re.compile(FILENAME_REGEXP)
        if authfile_matcher.match(args['s']) is None:
            # print >> sys.stderr, "invalid authfile %s" % args['s']
            sys.exit(255)

    if os.path.isfile(args['s']):
        pass
    else:
        print >> sys.stderr, "Authfile does exists: %s" % args['s']
        sys.exit(255)

    encodedkey = ""
    with open(args['s'], "r") as authfile:
        encodedkey = authfile.readlines()[0]

    if args['i'] is None:
        args['i'] = '127.0.0.1'
    else:
        ip_matcher = re.compile(IP_REGEXP)
        if ip_matcher.match(args['i']) is None:
            # print >> sys.stderr, "invalid ip %s" % args['i']
            sys.exit(255)

    if args['p'] is None:
        args['p'] = '3000'
    else:
        numeric_matcher = re.compile(NUMERIC_REGEXP)
        if numeric_matcher.match(args['p']) is None:
            # print >> sys.stderr, "invalid ip %s" % args['i']
            sys.exit(255)

    if args['c'] is None:
        args['c'] = "%s.card" % args['a']
    else:
        if args['c'] == '.' or args['c'] == '..':
            # print >> sys.stderr, "invalid cardfile %s" % args['c']
            sys.exit(255)
        cardfile_matcher = re.compile(FILENAME_REGEXP)
        if cardfile_matcher.match(args['c']) is None:
            # print >> sys.stderr, "invalid cardfile %s" % args['c']
            sys.exit(255)

    amount = -1
    if args['g']:
        pass
    else:
        amount_matcher = re.compile(AMOUNT_REGEXP)
        amount_match = None
        if args['n']:
            amount_match = amount_matcher.match(args['n'])
            if amount_match is None:
                # print >> sys.stderr, "invalid amount %s" % args['n']
                sys.exit(255)
        elif args['d']:
            amount_match = amount_matcher.match(args['d'])
            if amount_match is None:
                # print >> sys.stderr, "invalid amount %s" % args['d']
                sys.exit(255)
        elif args['w']:
            amount_match = amount_matcher.match(args['w'])
            if amount_match is None:
                # print >> sys.stderr, "invalid amount %s" % args['w']
                sys.exit(255)
        amount = float(amount_match.group())
        if amount < 0 or amount > 4294967295.99:
            # print >> sys.stderr, "invalid amount %s" % amount
            sys.exit(255)

    # print >> sys.stderr, args

    start = time.time()
    # Make socket
    transport = TSocket.TSocket(args['i'], int(args['p']))
    # print >> sys.stderr,  "Socket created: %s" % (time.time() - start)
    # Buffering is critical. Raw sockets are very slow
    transport = TTransport.TBufferedTransport(transport)

    # Wrap in a protocol
    protocol = TCompactProtocol.TCompactProtocol(transport)

    # Create a client to use the protocol encoder
    client = Client(protocol)
    # print >> sys.stderr,  "Client created: %s" % (time.time() - start)
    # Connect!
    transport.open()

    # print >> sys.stderr,  "Socket connected: %s" % (time.time() - start)

    w = W()
    w.a = args['a']
    w.t = int(round(time.time() * 1000))

    if args['n']:
        if os.path.isfile(args['c']):
            sys.exit(255)
        w.v = float(args['n'])
        card = client.c(w)
        if card == -1:
            sys.exit(255)
        elif card == -2:
            sys.exit(63)

        with open(args['c'], "w") as cardfile:
            cardfile.write('%s' % card)
        print '{"account":"%s","initial_balance":%s}' % (w.a, ("%.2f" % w.v).rstrip('0').rstrip('.'))
        sys.stdout.flush()
    elif args['d']:
        w.v = float(args['d'])
        with open(args['c'], "r") as cardfile:
            w.c = long(cardfile.readlines()[0])
        res = client.d(w)
        if not res:
            sys.exit(255)
        print '{"account":"%s","deposit":%s}' % (w.a, ("%.2f" % w.v).rstrip('0').rstrip('.'))
        sys.stdout.flush()
    elif args['w']:
        w.v = float(args['w'])
        with open(args['c'], "r") as cardfile:
            w.c = long(cardfile.readlines()[0])
        res = client.w(w)
        if not res:
            sys.exit(255)
        print '{"account":"%s","withdraw":%s}' % (w.a, ("%.2f" % w.v).rstrip('0').rstrip('.'))
        sys.stdout.flush()
    elif args['g']:
        with open(args['c'], "r") as cardfile:
            w.c = long(cardfile.readlines()[0])
        res = client.b(w)

        if res < 0:
            sys.exit(255)
        print '{"account":"%s","balance":%s}' % (w.a, ("%.2f" % res).rstrip('0').rstrip('.'))
        sys.stdout.flush()

    # print >> sys.stderr,  "Finished: %s" % (time.time() - start)
    sys.exit(0)

except argparse.ArgumentError, ex:
    print >> sys.stderr, '%s' % (ex.message)
    traceback.print_exc(ex)
    sys.exit(255)
except TException, ex:
    print >> sys.stderr, '%s' % (ex.message)
    traceback.print_exc(ex)
    sys.exit(63)
except Exception, ex:
    print >> sys.stderr,  '%s' % ex.message
    traceback.print_exc(ex)
    sys.exit(255)
